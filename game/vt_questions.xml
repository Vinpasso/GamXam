<?xml version="1.0" encoding="UTF-8" ?>
<exam xmlns="https://vpt1.org">
    <head>
        <title>Virtualization Technologies</title>
        <version>1.0</version>
    </head>
    <body>
        <question type="extended-answer">
            <body>
                Define Virtualization.
            </body>
            <answers type="any">
                <answer>
                    <body>
                        Construction of a virtual environment for an inner system using an outer system.
                    </body>
                    <marks>
                        <mark type="keyword">construction</mark>
                        <mark type="keyword">virtual environment</mark>
                        <mark type="keyword">inner system</mark>
                        <mark type="keyword">outer system</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>
                Define abstraction.
            </body>
            <answers>
                <answer>
                    <body>Provides a simplified interface from a complex interface</body>
                    <marks>
                        <mark type="keyword">simpl</mark>
                        <mark type="keyword">interface</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some criteria to classify VMs?</body>
            <answers>
                <answer>
                    <body>By level of abstraction</body>
                    <marks>
                        <mark type="keyword">abstraction</mark>
                    </marks>
                </answer>
                <answer>
                    <body>By emulation technique.</body>
                    <marks>
                        <mark type="keyword">emulation</mark>
                        <mark type="keyword">technique</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Level of hardware assistance.</body>
                    <marks>
                        <mark type="keyword">hardware</mark>
                        <mark type="keyword">assistance</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Define Interpretation</body>
            <answers>
                <answer>
                    <body>Step-by-Step emulation for every instruction</body>
                    <marks>
                        <mark type="keyword">instruction</mark>
                        <mark type="keyword">step</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>List some advantages of interpretation</body>
            <answers>
                <answer>
                    <body>Simple implementation</body>
                    <marks>
                        <mark type="keyword">implement</mark>
                    </marks>
                </answer>
                <answer>
                    <body>No setup time required</body>
                    <marks>
                        <mark type="keyword">setup</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Portable</body>
                    <marks>
                        <mark type="keyword">port</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>List some disadvantages of interpretation</body>
            <answers>
                <answer>
                    <body>Comparatively slow.</body>
                    <marks>
                        <mark type="keyword">slow</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Control hazards and branch mispredictions lead to pipeline stalls.</body>
                    <marks>
                        <mark type="keyword">control</mark>
                        <mark type="keyword">hazard</mark>
                        <mark type="keyword">pipeline</mark>
                        <mark type="keyword">stall</mark>
                        <mark type="keyword">branch</mark>
                        <mark type="keyword">mispredict</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Define direct threading</body>
            <answers>
                <answer>
                    <body>Use of pre-decoded data to jump directly to previously determined emulation routine.</body>
                    <marks>
                        <mark type="keyword">direct</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Differentiate between emulation and simulation</body>
            <answers>
                <answer>
                    <body>Emulation concerns itself with replicating the functional aspects of the original processor
                    </body>
                    <marks>
                        <mark type="keyword">functional</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Simulation also concerns itself with non-functional aspects, such as power consumption.</body>
                    <marks>
                        <mark type="keyword">non-functional</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Define indirect threading</body>
            <answers>
                <answer>
                    <body>Decode the next instruction at the end of the current instruction without returning to
                        emulation loop.
                    </body>
                    <marks>
                        <mark type="keyword">decode</mark>
                        <mark type="keyword">next instruction</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>List some advantages/disadvantages of indirect threading.</body>
            <answers>
                <answer>
                    <body>Better branch prediction when sequences of operations are similar. Reduced control hazards.
                    </body>
                    <marks>
                        <mark type="keyword">branch</mark>
                        <mark type="keyword">prediction</mark>
                        <mark type="keyword">control</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Code duplication happens in binary form</body>
                    <marks>
                        <mark type="keyword">duplicat</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Define Pre-decoding</body>
            <answers>
                <answer>
                    <body>Disassemble instructions into their parts ahead of time in batch. Convert to a single
                        opcode.
                    </body>
                    <marks>
                        <mark type="keyword">instruction</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some advantages of pre-decoding?</body>
            <answers>
                <answer>
                    <body>Aligned access to operands</body>
                    <marks>
                        <mark type="keyword">align</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Single opcode to make finding the next emulation function easier</body>
                    <marks>
                        <mark type="keyword">opcode</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Reusable decoded instructions</body>
                    <marks>
                        <mark type="keyword">reuse</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Allows for software-pipelining of decode/execute stages</body>
                    <marks>
                        <mark type="keyword">pipelin</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some disadvantages of pre-decoding?</body>
            <answers>
                <answer>
                    <body>Requires upfront decode stage in batch, increases setup time</body>
                    <marks>
                        <mark type="keyword">setup</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Requires significant amount of space to store decoded data</body>
                    <marks>
                        <mark type="keyword">space</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Detecting instruction borders might be hard</body>
                    <marks>
                        <mark type="keyword">instruction</mark>
                        <mark type="keyword">border</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is the difference between a static and a dynamic basic block?</body>
            <answers>
                <answer>
                    <body>Static basic block is single entry, single exit</body>
                    <marks>
                        <mark type="keyword">single entry</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Dynamic basic block is multi entry, single exit</body>
                    <marks>
                        <mark type="keyword">multi entry</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some of the similarities and differences between a normal cache and a code cache?</body>
            <answers>
                <answer>
                    <body>Difference: Code cache has a variable line length</body>
                    <marks>
                        <mark type="keyword">length</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Similarity: Limited size</body>
                    <marks>
                        <mark type="keyword">size</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Difference: Multiple translations can co-exist for same instruction</body>
                    <marks>
                        <mark type="keyword">multiple</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Difference: Cache lines have interdependencies.</body>
                    <marks>
                        <mark type="keyword">interdependenc</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>When does a translated basic block need to be invalidated? How is this detected?</body>
            <answers>
                <answer>
                    <body>When the code has modified itself.</body>
                    <marks>
                        <mark type="keyword">modif</mark>
                    </marks>
                </answer>
                <answer>
                    <body>With hardware support where possible using memory protection of MMU or in software if
                        necessary. It can also be ignored
                    </body>
                    <marks>
                        <mark type="keyword">hardware</mark>
                        <mark type="keyword">MMU</mark>
                        <mark type="keyword">software</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is the difference between a basic block and a super block? When are they built?</body>
            <answers>
                <answer>
                    <body>Super blocks are multi-exit, basic blocks are single-exit</body>
                    <marks>
                        <mark type="keyword">multi</mark>
                        <mark type="keyword">exit</mark>
                    </marks>
                </answer>
                <answer>
                    <body>On a pass through the code</body>
                    <marks>
                        <mark type="keyword">pass</mark>
                        <mark type="keyword">through</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What types of profiles are there and what are their advantages?</body>
            <answers>
                <answer>
                    <body>The node profile counts have many times a basic block has been executed. It takes less space
                    </body>
                    <marks>
                        <mark type="keyword">node</mark>
                        <mark type="keyword">basic</mark>
                        <mark type="keyword">space</mark>
                    </marks>
                </answer>
                <answer>
                    <body>The edge profile counts the number of times a transition between two basic blocks was taken.
                        This allows the construction of an optimal super block.
                    </body>
                    <marks>
                        <mark type="keyword">transition</mark>
                        <mark type="keyword">super</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is chaining? What are its advantages?</body>
            <answers>
                <answer>
                    <body>Linking a translated basic block, which has 1 or 2 exits, to the following basic block.</body>
                    <marks>
                        <mark type="keyword">link</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Better branch prediction</body>
                    <marks>
                        <mark type="keyword">branch</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Fewer control hazards</body>
                    <marks>
                        <mark type="keyword">control</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How is chaining implemented for its different scenarios?</body>
            <answers>
                <answer>
                    <body>(Conditional) jump: link path with higher probability (the more likely path)</body>
                    <marks>
                        <mark type="keyword">jump</mark>
                        <mark type="keyword">probability</mark>
                        <mark type="keyword">like</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Return from call: Maintain shadow stack with return addresses</body>
                    <marks>
                        <mark type="keyword">ret</mark>
                        <mark type="keyword">shadow</mark>
                        <mark type="keyword">stack</mark>
                        <mark type="keyword">address</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Indirect jump: Remember the last k targets, else abort</body>
                    <marks>
                        <mark type="keyword">indirect</mark>
                        <mark type="keyword">last</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What needs to happen when code cache lines are evicted?</body>
            <answers>
                <answer>
                    <body>Superblocks need to be unchained.</body>
                    <marks>
                        <mark type="keyword">super</mark>
                        <mark type="keyword">unchain</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some code cache eviction strategies?</body>
            <answers>
                <answer>
                    <body>Least recently used: Not used so often, because it generates overhead when trying to track
                        what is used and may produce a lot of fragmentation.
                    </body>
                    <marks>
                        <mark type="keyword">recent</mark>
                        <mark type="keyword">overhead</mark>
                        <mark type="keyword">fragmentation</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Complete flush when cache is full</body>
                    <marks>
                        <mark type="keyword">flush</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Coarse grained FIFO. Little overhead and basic blocks can be chained inside FIFO sector.
                    </body>
                    <marks>
                        <mark type="keyword">FIFO</mark>
                        <mark type="keyword">coarse</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some advantages of HLL-VMs?</body>
            <answers>
                <answer>
                    <body>Automatic utilization of new hardware.</body>
                    <marks>
                        <mark type="keyword">new hardware</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Same binary can be deployed on many platforms.</body>
                    <marks>
                        <mark type="keyword">platform</mark>
                        <mark type="keyword">deploy</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Less maintenance of ported software for authors</body>
                    <marks>
                        <mark type="keyword">maintenance</mark>
                        <mark type="keyword">port</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Reduced need for hardware backwards compatibility</body>
                    <marks>
                        <mark type="keyword">backward</mark>
                        <mark type="keyword">compatibility</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some disadvantages of HLL-VMs?</body>
            <answers>
                <answer>
                    <body>Running binaries requires a VM at runtime</body>
                    <marks>
                        <mark type="keyword">VM</mark>
                        <mark type="keyword">runtime</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Increased resource consumption due to VMM needing space and time</body>
                    <marks>
                        <mark type="keyword">resource</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Decreased performance since emulation needs to happen at runtime.</body>
                    <marks>
                        <mark type="keyword">performance</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Performance optimizations become harder/impossible if target architecture unknown.</body>
                    <marks>
                        <mark type="keyword">optimization</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Process-VMs can target the same or a different OS as well as the same or a different ISA. Give a use
                case and an example for each of same/same, same/different, different/same.
            </body>
            <answers>
                <answer>
                    <body>Same OS, same ISA: To isolate the process for analysis such as debugging or performance
                        monitoring. Valgrind is used for this application.
                    </body>
                    <marks>
                        <mark type="keyword">analysis</mark>
                        <mark type="keyword">valgrind</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Same OS, different ISA: To maintain compatibility of programs when OS is ported to a new ISA.
                        Example: Rosetta in MacOS
                    </body>
                    <marks>
                        <mark type="keyword">port</mark>
                        <mark type="keyword">rosetta</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Different OS, same ISA: To allow applications only available for certain OSs to run on other
                        OSs without porting them. Example: Microsoft Office on linux.
                    </body>
                    <marks>
                        <mark type="keyword">application</mark>
                        <mark type="keyword">office</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some components required for a Process VM?</body>
            <answers>
                <answer>
                    <body>An Emulation Manager and binary translation, if targeting a different ISA or instrumenting
                        code for the same ISA
                    </body>
                    <marks>
                        <mark type="keyword">translation</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Virtualization of OS-Calls</body>
                    <marks>
                        <mark type="keyword">os</mark>
                        <mark type="keyword">calls</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Guest Memory</body>
                    <marks>
                        <mark type="keyword">guest</mark>
                        <mark type="keyword">memory</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Emulation of interrupts and exceptions</body>
                    <marks>
                        <mark type="keyword">interrupt</mark>
                        <mark type="keyword">exception</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Code cache</body>
                    <marks>
                        <mark type="keyword">cache</mark>
                    </marks>
                </answer>
                <answer>
                    <body>An initialization phase for signal handlers, memory setup, loading of data.</body>
                    <marks>
                        <mark type="keyword">initialization</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>State the two types of compatibility and give a short explanation</body>
            <answers>
                <answer>
                    <body>Strict compatibility: Every operation of a real machine is precisely emulated. The real
                        properties have to be known and a complete check of the VM implementation is required.
                    </body>
                    <marks>
                        <mark type="keyword">strict</mark>
                        <mark type="keyword">operation</mark>
                        <mark type="keyword">real</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Relaxed compatibility: The strict compatibility is approximated by avoiding hard cases</body>
                    <marks>
                        <mark type="keyword">relax</mark>
                        <mark type="keyword">approx</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some problems that can arise when trying to implement strict compatibility?</body>
            <answers>
                <answer>
                    <body>The behavior of the real system might not be known completely.</body>
                    <marks>
                        <mark type="keyword">behavior</mark>
                        <mark type="keyword">real</mark>
                    </marks>
                </answer>
                <answer>
                    <body>The precise mapping between exec and exec&apos; can be very inefficient</body>
                    <marks>
                        <mark type="keyword">efficient</mark>
                        <mark type="keyword">performance</mark>
                    </marks>
                </answer>
                <answer>
                    <body>High development cost when needing to emulate complicated behavior correctly. This is
                        especially problematic if the guest doesn't end p noticing the difference anyway.
                    </body>
                    <marks>
                        <mark type="keyword">cost</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is the relationship between exec and exec&apos; if there is strict compatibility?</body>
            <answers>
                <answer>
                    <body>exec is completely emulated (replicated) by exec&apos;.</body>
                    <marks>
                        <mark type="keyword">emulate</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How is sufficiently approximated defined in relaxed compatibility?</body>
            <answers>
                <answer>
                    <body>By the guest software being able to tolerate the differences without major consequences.
                    </body>
                    <marks>
                        <mark type="keyword">guest</mark>
                        <mark type="keyword">software</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How can correctness verification be simplified?</body>
            <answers>
                <answer>
                    <body>By splitting up operations (instructions, OS interactions) and state (memory, register,
                        files, connections) of a process.
                    </body>
                    <marks>
                        <mark type="keyword">operation</mark>
                        <mark type="keyword">state</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What issues could arise during correctness verification?</body>
            <answers>
                <answer>
                    <body>When testing individual instructions, optimizations are not tested.</body>
                    <marks>
                        <mark type="keyword">optimization</mark>
                    </marks>
                </answer>
                <answer>
                    <body>When testing sequences of instructions, an emulator may not have a consistent state between
                        instructions, only at the start and end, due to optimizations.
                    </body>
                    <marks>
                        <mark type="keyword">consistent</mark>
                        <mark type="keyword">state</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What issues could arise in the attempt to create a guest to host mapping?</body>
            <answers>
                <answer>
                    <body>The host might have fewer registers than the guest. Registers need to be allocated
                        dynamically.
                    </body>
                    <marks>
                        <mark type="keyword">register</mark>
                        <mark type="keyword">dynamic</mark>
                        <mark type="keyword">allocate</mark>
                    </marks>
                </answer>
                <answer>
                    <body>The address space of the host might be smaller than the address space of the guest.</body>
                    <marks>
                        <mark type="keyword">address</mark>
                    </marks>
                </answer>
                <answer>
                    <body>There might not be a good mapping between guest OS-calls and host OS-calls</body>
                    <marks>
                        <mark type="keyword">os-calls</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Some exceptions or interrupts might need to be emulated in software if the host does not
                        support or does not make them visible.
                    </body>
                    <marks>
                        <mark type="keyword">exception</mark>
                        <mark type="keyword">interrupt</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Some exceptions or interrupts might need to be intercepted if the guest does not know about
                        them.
                    </body>
                    <marks>
                        <mark type="keyword">intercept</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Some exceptions or interrupts on the host may corresponds to multiple different exceptions or
                        interrupts on the guest. The VMM needs to distinguish between them and trigger the correct
                        signal.
                    </body>
                    <marks>
                        <mark type="keyword">distinguish</mark>
                    </marks>
                </answer>
                <answer>
                    <body>It might be hard or inefficient to protect the host memory without support from the
                        hardware.
                    </body>
                    <marks>
                        <mark type="keyword">protect</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What type of mappings exist for memory?</body>
            <answers>
                <answer>
                    <body>Direct mapping: Uses a fixed offset to map from guest memory to host memory. Special case is
                        if the offset can be zero because the guest software accepts arbitrary addresses
                    </body>
                    <marks>
                        <mark type="keyword">offset</mark>
                        <mark type="keyword">direct</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Indirect mapping: A page table is implemented in software. Unfortunately, this is relatively
                        slow and requires memory itself.
                    </body>
                    <marks>
                        <mark type="keyword">page table</mark>
                        <mark type="keyword">indirect</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some problems that can occur when emulating a different ISA?</body>
            <answers>
                <answer>
                    <body>Fewer registers on the host</body>
                    <marks>
                        <mark type="keyword">register</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Unsupported data types used by guest, e.g. 80 bit floating point.</body>
                    <marks>
                        <mark type="keyword">data type</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Host may be missing status flags or predication required by guest. Emulate in software lazily
                        where possible
                    </body>
                    <marks>
                        <mark type="keyword">status</mark>
                        <mark type="keyword">predicat</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Host may have a different memory model to guest considering word size,
                        alignment, byte order, consistency model
                    </body>
                    <marks>
                        <mark type="keyword">memory</mark>
                        <mark type="keyword">size</mark>
                        <mark type="keyword">alignment</mark>
                        <mark type="keyword">order</mark>
                        <mark type="keyword">consistenc</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Exception and interrupt handling, the source program counter needs to be recalculated.</body>
                    <marks>
                        <mark type="keyword">exception</mark>
                        <mark type="keyword">counter</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are the conditions for Precise Exception Handling (PEH)?</body>
            <answers>
                <answer>
                    <body>All instructions before X are executed when X triggers an exception</body>
                    <marks>
                        <mark type="keyword">before</mark>
                    </marks>
                </answer>
                <answer>
                    <body>All instructions after X have not yet been executed when X triggers an exception</body>
                    <marks>
                        <mark type="keyword">after</mark>
                    </marks>
                </answer>
                <answer>
                    <body>X itself has not been executed yet.</body>
                    <marks>
                        <mark type="keyword">execute</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Why is it easier to implement Precise Exception Handling (PEH) for interrupts rather than
                exceptions?
            </body>
            <answers>
                <answer>
                    <body>Because interrupts have less strict time constraints. They can be triggered after the
                        execution has returned to the hypervisor and the guest is in a consistent state.
                    </body>
                    <marks>
                        <mark type="keyword">time</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What does the Application Binary Interface specify?</body>
            <answers>
                <answer>
                    <body>Calling conventions</body>
                    <marks>
                        <mark type="keyword">calling</mark>
                        <mark type="keyword">convention</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Available OS-calls</body>
                    <marks>
                        <mark type="keyword">os-call</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Exceptions and interrupts</body>
                    <marks>
                        <mark type="keyword">exceptions</mark>
                        <mark type="keyword">interrupts</mark>
                    </marks>
                </answer>
                <answer>
                    <body>User ISA</body>
                    <marks>
                        <mark type="keyword">user isa</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Data types directly accessible by processor</body>
                    <marks>
                        <mark type="keyword">data type</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Binary format of object files and libraries</body>
                    <marks>
                        <mark type="keyword">object</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is an ISA and what parts belong to it?</body>
            <answers>
                <answer>
                    <body>An abstract specification of a computer and its capabilities. It is the interface between the
                        system&apos;s processor (the kind of resource that can run instructions) and its software.
                    </body>
                    <marks>
                        <mark type="keyword">specification</mark>
                        <mark type="keyword">abstract</mark>
                        <mark type="keyword">resource</mark>
                        <mark type="keyword">instructions</mark>
                        <mark type="keyword">software</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Available instructions, their format, their operands, results and side-effects</body>
                    <marks>
                        <mark type="keyword">instructions</mark>
                        <mark type="keyword">format</mark>
                        <mark type="keyword">operands</mark>
                        <mark type="keyword">effects</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Available registers</body>
                    <marks>
                        <mark type="keyword">register</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Supported data types</body>
                    <marks>
                        <mark type="keyword">type</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Memory model: consistency, addressing modes, support for virtual memory.</body>
                    <marks>
                        <mark type="keyword">consistency</mark>
                        <mark type="keyword">memory</mark>
                        <mark type="keyword">address</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Input/Output model</body>
                    <marks>
                        <mark type="keyword">input</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Level of permissions (user/system) mode</body>
                    <marks>
                        <mark type="keyword">permission</mark>
                        <mark type="keyword">user</mark>
                        <mark type="keyword">system</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Exceptions and interrupts</body>
                    <marks>
                        <mark type="keyword">exception</mark>
                        <mark type="keyword">interrupt</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is a calling convention? What does it specify?</body>
            <answers>
                <answer>
                    <body>The interface between a caller and callee.</body>
                    <marks>
                        <mark type="keyword">interface</mark>
                        <mark type="keyword">call</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Where to specify parameters</body>
                    <marks>
                        <mark type="keyword">parameter</mark>
                    </marks>
                </answer>
                <answer>
                    <body>How to store the return address and return value</body>
                    <marks>
                        <mark type="keyword">return</mark>
                        <mark type="keyword">address</mark>
                        <mark type="keyword">value</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are the generic parts of the encoding of an x86 instruction?</body>
            <answers>
                <answer>
                    <body>Opcode</body>
                    <marks>
                        <mark type="keyword">opcode</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Possibly an opcode extension</body>
                    <marks>
                        <mark type="keyword">extension</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Up to two register operands</body>
                    <marks>
                        <mark type="keyword">register</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Up to one memory operand</body>
                    <marks>
                        <mark type="keyword">memory</mark>
                    </marks>
                </answer>
                <answer>
                    <body>An immediate</body>
                    <marks>
                        <mark type="keyword">immediate</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some benefits/drawbacks of a pipeline in CPU design?</body>
            <answers>
                <answer>
                    <body>Allows for higher frequency</body>
                    <marks>
                        <mark type="keyword">frequenc</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Higher throughput</body>
                    <marks>
                        <mark type="keyword">throughput</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Higher latency</body>
                    <marks>
                        <mark type="keyword">latency</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are pipeline conflicts? Give three examples of hazards.</body>
            <answers>
                <answer>
                    <body>Problems in the pipeline that prevent executing the next instruction in the next cycle,
                        causing the pipeline to stall. This reduces throughput and increases
                        latency.
                    </body>
                    <marks>
                        <mark type="keyword">stall</mark>
                        <mark type="keyword">cycle</mark>
                    </marks>
                </answer>
                <answer>
                    <body>A data hazard is when an instruction depends on an earlier instruction for which the result is
                        not available yet.
                    </body>
                    <marks>
                        <mark type="keyword">data</mark>
                        <mark type="keyword">result</mark>
                    </marks>
                </answer>
                <answer>
                    <body>A control hazard is when the execution flow is changed (especially when conditional change is
                        involved) and the processor needs to wait for the
                        change before the pipeline can resume.
                    </body>
                    <marks>
                        <mark type="keyword">control</mark>
                        <mark type="keyword">execut</mark>
                    </marks>
                </answer>
                <answer>
                    <body>A structural hazard is when a component of the processor wants to be accessed by two different
                        instructions simultaneously and one instruction needs to be delayed.
                    </body>
                    <marks>
                        <mark type="keyword">structur</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What causes jumps or calls to be slow and how slow ar they?</body>
            <answers>
                <answer>
                    <body>Pipeline stalls, especially when due to branch misprediction</body>
                    <marks>
                        <mark type="keyword">stall</mark>
                        <mark type="keyword">mispredict</mark>
                    </marks>
                </answer>
                <answer>
                    <body>On MIPS: 2/5 cycles</body>
                    <marks>
                        <mark type="keyword">cycle</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What belongs to the state of a linux process?</body>
            <answers>
                <answer>
                    <body>Register contents</body>
                    <marks>
                        <mark type="keyword">register</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Memory contents</body>
                    <marks>
                        <mark type="keyword">memory</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Kernel data structures</body>
                    <marks>
                        <mark type="keyword">kernel</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is Valgrind? What are its tools?</body>
            <answers>
                <answer>
                    <body>A program that uses virtualization in order to analyze programs. To do so, it adds
                        instrumentation code to the application.
                    </body>
                    <marks>
                        <mark type="keyword">virtual</mark>
                        <mark type="keyword">analy</mark>
                        <mark type="keyword">instrument</mark>
                    </marks>
                </answer>
                <answer>
                    <body>A tool is a component of valgrind that analyzes a specific aspect of the program under
                        inspection.
                    </body>
                    <marks>
                        <mark type="keyword">aspect</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What does memcheck do?</body>
            <answers>
                <answer>
                    <body>Attempts to find unintended memory accesses in the program under analysis that might be legal
                        but caused by a bug. These can be hard to find.
                    </body>
                    <marks>
                        <mark type="keyword">memory</mark>
                        <mark type="keyword">uninten</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What does the tool &quot;none&quot; do?</body>
            <answers>
                <answer>
                    <body>Runs the executable on valgrind&apos;s synthetic CPU without any additional instrumentation.
                    </body>
                    <marks>
                        <mark type="keyword">instrument</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are three common attributes of a HLL-ABI?</body>
            <answers>
                <answer>
                    <body>High abstraction level.</body>
                    <marks>
                        <mark type="keyword">abstraction</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Typically without any real machine implementation</body>
                    <marks>
                        <mark type="keyword">real</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Only contains user level instructions</body>
                    <marks>
                        <mark type="keyword">user</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some of the advantages of a freely constructable ABI?</body>
            <answers>
                <answer>
                    <body>You can use higher abstractions: Synchronization, complex data types</body>
                    <marks>
                        <mark type="keyword">abstraction</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Robust programming models: Automatic memory management, object orientation</body>
                    <marks>
                        <mark type="keyword">robust</mark>
                        <mark type="keyword">memory</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Compact code as machine already provides features out of the box</body>
                    <marks>
                        <mark type="keyword">compact</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Security features at ABI level: Permission policies and code/data checking</body>
                    <marks>
                        <mark type="keyword">security</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Easy emulation, doesn't suffer from any real hardware complications</body>
                    <marks>
                        <mark type="keyword">emulation</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some goals of the JVM platform?</body>
            <answers>
                <answer>
                    <body>Object orientation</body>
                    <marks>
                        <mark type="keyword">orientation</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Robustness by garbage collection and security policies</body>
                    <marks>
                        <mark type="keyword">robust</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Network integration for code loading</body>
                    <marks>
                        <mark type="keyword">network</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Easy portability to ISAs and OSs</body>
                    <marks>
                        <mark type="keyword">port</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What kind of data types does the JVM ABI know?</body>
            <answers>
                <answer>
                    <body>Primitives</body>
                    <marks>
                        <mark type="keyword">primitive</mark>
                    </marks>
                </answer>
                <answer>
                    <body>References: Objects, arrays, null</body>
                    <marks>
                        <mark type="keyword">references</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What components does the JVM memory model include</body>
            <answers>
                <answer>
                    <body>Stack: function parameters, local variables and operands.</body>
                    <marks>
                        <mark type="keyword">stack</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Heap: For static and dynamic objects accessed over typed references.</body>
                    <marks>
                        <mark type="keyword">heap</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Constant pool: Constant primitives or references defined in class file.</body>
                    <marks>
                        <mark type="keyword">constant</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What advantages does a V-ISA have over a legacy ISA</body>
            <answers>
                <answer>
                    <body>V-ISAs do not have pointers that can be modified (only references)</body>
                    <marks>
                        <mark type="keyword">reference</mark>
                    </marks>
                </answer>
                <answer>
                    <body>No self modifying code</body>
                    <marks>
                        <mark type="keyword">modif</mark>
                    </marks>
                </answer>
                <answer>
                    <body>No dependence on OS-behavior</body>
                    <marks>
                        <mark type="keyword">os</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Separation of code and data</body>
                    <marks>
                        <mark type="keyword">data</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is the algorithm of the Java VM Garbage Collector? What are some optimizations?</body>
            <answers>
                <answer>
                    <body>The basic algorithms is Mark and Sweep</body>
                    <marks>
                        <mark type="keyword">mark</mark>
                        <mark type="keyword">sweep</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Compact memory on high fragmentation</body>
                    <marks>
                        <mark type="keyword">compact</mark>
                        <mark type="keyword">fragement</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Seperate pool for short and long lived objects</body>
                    <marks>
                        <mark type="keyword">pool</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Asynchronous, less impact on running application (some amount of synchronization necessary)
                    </body>
                    <marks>
                        <mark type="keyword">async</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are the tasks of the V-ISA loader?</body>
            <answers>
                <answer>
                    <body>Fetching binaries (potentially over the network)</body>
                    <marks>
                        <mark type="keyword">binar</mark>
                        <mark type="keyword">network</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Resolving dependencies</body>
                    <marks>
                        <mark type="keyword">dependenc</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Verification of binary</body>
                    <marks>
                        <mark type="keyword">verif</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Enforcing security policies/permissions</body>
                    <marks>
                        <mark type="keyword">security</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Where is Java code typically optimized? What are some advantages?</body>
            <answers>
                <answer>
                    <body>In the HLL-VM.</body>
                    <marks>
                        <mark type="keyword">vm</mark>
                    </marks>
                </answer>
                <answer>
                    <body>No recompilation needed to improve performance</body>
                    <marks>
                        <mark type="keyword">recompil</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Binaries can be tuned at runtime using profiling info</body>
                    <marks>
                        <mark type="keyword">profil</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some aspects of object oriented environments that make optimization of the HLL-VM
                essential?
            </body>
            <answers>
                <answer>
                    <body>Frequent use of indirections</body>
                    <marks>
                        <mark type="keyword">indirect</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Many very short methods</body>
                    <marks>
                        <mark type="keyword">method</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some methods for optimizing HLL binary code?</body>
            <answers>
                <answer>
                    <body>Inlining: To fix problems with short methods. Need to avoid code explosion.</body>
                    <marks>
                        <mark type="keyword">inlin</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Multiversioning: Generate several more/less specific variants of a method as an alternative to
                        inlining, can be generated on demand. Need a type or value guard to ensure safety.
                    </body>
                    <marks>
                        <mark type="keyword">version</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Object layout: Reduce number of indirections by substituting objects with variables and
                        eliminating nesting.
                    </body>
                    <marks>
                        <mark type="keyword">layout</mark>
                        <mark type="keyword">indirect</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What types of System-VMs are there? Give 1 example</body>
            <answers>
                <answer>
                    <body>Type 1: System level. The VM runs on bare metal hardware without an underlying operating
                        system. This is sometimes called a native VM. Xen is an implementation.
                    </body>
                    <marks>
                        <mark type="keyword">system</mark>
                        <mark type="keyword">Xen</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Type 2: User level. The hypervisor runs completely inside an operating system&apos;s user
                        mode. QEmu is an example.
                    </body>
                    <marks>
                        <mark type="keyword">user</mark>
                        <mark type="keyword">qemu</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Splitted-VM or Dual-Mode Hosted VM. The hypervisor runs mainly in user
                        mode but has a module in the host&apos;s system
                        mode to support virtualization. VirtualBox is a splitted-vm when running without VTx.
                    </body>
                    <marks>
                        <mark type="keyword">split</mark>
                        <mark type="keyword">host</mark>
                        <mark type="keyword">virtualbox</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some use cases for System-VMs?</body>
            <answers>
                <answer>
                    <body>Increased security, robustness</body>
                    <marks>
                        <mark type="keyword">secur</mark>
                        <mark type="keyword">robust</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Distribution of applications as appliances (especially stacks).</body>
                    <marks>
                        <mark type="keyword">distribut</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Testing applications and OSs in different environments</body>
                    <marks>
                        <mark type="keyword">test</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Running applications developed for another system</body>
                    <marks>
                        <mark type="keyword">run</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What sub-resources of CPU, Memory, I/O and others need to be virtualized in System VMs and Process
                VMs
            </body>
            <answers>
                <answer>
                    <body>CPU: A process vm only needs user-ISA while a system vm needs both user and system ISA (MMU,
                        configuration registers, etc.)
                    </body>
                    <marks>
                        <mark type="keyword">user</mark>
                        <mark type="keyword">system</mark>
                        <mark type="keyword">isa</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Memory: A process vm needs to emulate the linear address space of a process, while a system vm
                        needs to emulate the entire physical memory
                    </body>
                    <marks>
                        <mark type="keyword">linear</mark>
                        <mark type="keyword">physical</mark>
                    </marks>
                </answer>
                <answer>
                    <body>IO/Devices: A process vm accesses these only over system calls, while a system-vm needs to
                        actually emulate the physical hardware devices
                    </body>
                    <marks>
                        <mark type="keyword">call</mark>
                        <mark type="keyword">device</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Time may need to be virtualized</body>
                    <marks>
                        <mark type="keyword">time</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is meant by the term paravirtualization? What is it used for?</body>
            <answers>
                <answer>
                    <body>Bypassing virtualization needs by modification of guest to use VM-specific extensions to the
                        machine interface using hypercalls that call directly into the hypervisor.
                    </body>
                    <marks>
                        <mark type="keyword">modif</mark>
                        <mark type="keyword">guest</mark>
                        <mark type="keyword">exten</mark>
                        <mark type="keyword">hypercall</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Aims to increase performance and simplify implementation of the hypervisor.</body>
                    <marks>
                        <mark type="keyword">perform</mark>
                        <mark type="keyword">simpl</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>Describe the possibilities of state mapping, how the guest-to-guest switches work, and give an
                application of each
            </body>
            <answers>
                <answer>
                    <body>Indirection: A switch from guest to guest modifies a pointer to the guest data. Useful for
                        e.g. locating the guest memory
                    </body>
                    <marks>
                        <mark type="keyword">indirect</mark>
                        <mark type="keyword">point</mark>
                        <mark type="keyword">memory</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Fixed mapping: A switch from guest to guest requires copying data. Useful for registers which
                        are stored directly in the CPU when guest is running.
                    </body>
                    <marks>
                        <mark type="keyword">fixed</mark>
                        <mark type="keyword">map</mark>
                        <mark type="keyword">register</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are the possible types of resource assignments?</body>
            <answers>
                <answer>
                    <body>Pass-through</body>
                    <marks>
                        <mark type="keyword">pass</mark>
                        <mark type="keyword">through</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Partitioning</body>
                    <marks>
                        <mark type="keyword">partition</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Sharing: Dynamic scheduling, time slicing</body>
                    <marks>
                        <mark type="keyword">shar</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Spooling: Queue jobs and assign one by one</body>
                    <marks>
                        <mark type="keyword">spool</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Emulation: Fall-back that does not require host resource</body>
                    <marks>
                        <mark type="keyword">emulat</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are different types of assignment scheduling?</body>
            <answers>
                <answer>
                    <body>Fixed (configured)</body>
                    <marks>
                        <mark type="keyword">fix</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Automatic (needs to be fair)</body>
                    <marks>
                        <mark type="keyword">auto</mark>
                    </marks>
                </answer>
                <answer>
                    <body>User controlled (mouse and keyboard or other periphery)</body>
                    <marks>
                        <mark type="keyword">user</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What constitutes a privileged resource? How is this resource virtualized?</body>
            <answers>
                <answer>
                    <body>A resource the cannot be assigned to a guest because the host or hypervisor needs it or the
                        assignment is not revocable at arbitrary times. The privileged resource needs to be emulated.
                    </body>
                    <marks>
                        <mark type="keyword">assign</mark>
                        <mark type="keyword">host</mark>
                        <mark type="keyword">revo</mark>
                        <mark type="keyword">emulat</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some examples of privileged resources?</body>
            <answers>
                <answer>
                    <body>Interval timer. Used by host to schedule CPU revocation.</body>
                    <marks>
                        <mark type="keyword">time</mark>
                    </marks>
                </answer>
                <answer>
                    <body>MMU: Need to protect host memory and prevent modification by guest</body>
                    <marks>
                        <mark type="keyword">mmu</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Interrupt control. Guest should not receive interrupts for other guests or the host.</body>
                    <marks>
                        <mark type="keyword">interrupt</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some workarounds for the driver problem in Type-1 system VMs and which solutions use them?
            </body>
            <answers>
                <answer>
                    <body>Xen: use drivers from a special Dom0 guest and provide them to other guests.</body>
                    <marks>
                        <mark type="keyword">xen</mark>
                        <mark type="keyword">dom0</mark>
                    </marks>
                </answer>
                <answer>
                    <body>IBM: embed the drivers into the hypervisor, since both are manufactured by IBM</body>
                    <marks>
                        <mark type="keyword">embed</mark>
                        <mark type="keyword">ibm</mark>
                    </marks>
                </answer>
                <answer>
                    <body>VMWare ESX: Support certified hardware only</body>
                    <marks>
                        <mark type="keyword">vmware</mark>
                        <mark type="keyword">certif</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is a privileged instruction?</body>
            <answers>
                <answer>
                    <body>An instruction accessing a privileged resource meant to run in the system mode of a processor
                        that throws an exception if run in user mode
                    </body>
                    <marks>
                        <mark type="keyword">privilege</mark>
                        <mark type="keyword">resource</mark>
                        <mark type="keyword">system</mark>
                        <mark type="keyword">exception</mark>
                        <mark type="keyword">user</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is the Popek and Goldberg conditions?</body>
            <answers>
                <answer>
                    <body>A sufficient condition for efficient implementation of resource access: Every instruction
                        accessing a privileged resource is privileged.
                    </body>
                    <marks>
                        <mark type="keyword">sufficient</mark>
                        <mark type="keyword">efficient</mark>
                        <mark type="keyword">privilege</mark>
                        <mark type="keyword">access</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What hardware support is needed to efficiently virtualize the CPU?</body>
            <answers>
                <answer>
                    <body>Different levels of privilege in the CPU</body>
                    <marks>
                        <mark type="keyword">privilege</mark>
                        <mark type="keyword">level</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Access to privileged resource in user level generates exception</body>
                    <marks>
                        <mark type="keyword">access</mark>
                        <mark type="keyword">user</mark>
                        <mark type="keyword">exception</mark>
                    </marks>
                </answer>
                <answer>
                    <body>The hypervisor can catch any exceptions caused by this access.</body>
                    <marks>
                        <mark type="keyword">catch</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What is a critical instruction? What needs to happen to virtualize a resource with critical
                instructions?
            </body>
            <answers>
                <answer>
                    <body>An instruction that accesses a privileged resource but does not generate an exception in user
                        mode. Any ISA with critical instructions does not fulfill the Popek and Goldberg condition.
                    </body>
                    <marks>
                        <mark type="keyword">privilege</mark>
                        <mark type="keyword">exception</mark>
                        <mark type="keyword">user</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Critical instructions need to be removed and emulated or paravirtualized.</body>
                    <marks>
                        <mark type="keyword">emulate</mark>
                        <mark type="keyword">paravirtual</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are the two levels of hardware support for virtualizing memory specified in the ISA?</body>
            <answers>
                <answer>
                    <body>Page table part of ISA. The TLB is not visible, lookups are done directly in hardware.</body>
                    <marks>
                        <mark type="keyword">page table</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Page table not part of ISA. The TLB is administered by OS.</body>
                    <marks>
                        <mark type="keyword">page table</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How is the virtual page table implemented if page tables are part of the ISA (TLB not ISA-visible)?
            </body>
            <answers>
                <answer>
                    <body>Actual page table contains composition (virtual guest -> physical guest -> physical host).
                        This is called the Shadow Page Table (SPT). The guest page table is stored somewhere in memory
                        for modification by guest and updating of the shadow page table.
                    </body>
                    <marks>
                        <mark type="keyword">composit</mark>
                        <mark type="keyword">shadow</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What happens if there is a Page Fault while VMM is active and page tables are part of the ISA?</body>
            <answers>
                <answer>
                    <body>Physical memory of guest not available. Host OS makes the memory available.</body>
                    <marks>
                        <mark type="keyword">physical</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Virtual memory of process in guest not available. Host passes page fault to hypervisor, which
                        passes the page fault to the guest OS. The guest OS modifies its table und the hypervisor
                        modifies the shadow.
                    </body>
                    <marks>
                        <mark type="keyword">virtual</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Illegal memory access in guest process. Pass along chain, then guest OS kills or signals
                        process.
                    </body>
                    <marks>
                        <mark type="keyword">illegal</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What happens if there is a page fault while VMM is active and page tables are not part of the ISA?
                What needs to happen to facilitate guest switching?
            </body>
            <answers>
                <answer>
                    <body>When the TLB misses, the exception is passed through to the guest OS. The guest configures a
                        new VTLB entry, and the hypervisor updates the actual TLB with double indirection.
                    </body>
                    <marks>
                        <mark type="keyword">tlb</mark>
                        <mark type="keyword">guest</mark>
                        <mark type="keyword">update</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Either invalidate all VTLB entries in actual TLB or virtualize the ASID register (each guest
                        and guest process gets an ASID. Remap when ASIDs run out.)
                    </body>
                    <marks>
                        <mark type="keyword">invalid</mark>
                        <mark type="keyword">asid</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some potential bottlenecks for System-VMs?</body>
            <answers>
                <answer>
                    <body>Start up</body>
                    <marks>
                        <mark type="keyword">start</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Switching between user/system mode</body>
                    <marks>
                        <mark type="keyword">user</mark>
                        <mark type="keyword">mode</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Handling of frequent interrupts/exceptions by hypervisor</body>
                    <marks>
                        <mark type="keyword">interrupt</mark>
                        <mark type="keyword">exception</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Guest switching (lots of save and restore)</body>
                    <marks>
                        <mark type="keyword">switch</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Resource emulation where other types of virtualization not possible</body>
                    <marks>
                        <mark type="keyword">emulat</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How can the hardware support the hypervisor?</body>
            <answers>
                <answer>
                    <body>Extension of host ISA specific for hypervisor, including special instructions for fast binary
                        translation
                    </body>
                    <marks>
                        <mark type="keyword">isa</mark>
                        <mark type="keyword">instruction</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Memory hardware virtualization through nested page tables or tagged TLBs</body>
                    <marks>
                        <mark type="keyword">memory</mark>
                        <mark type="keyword">nested</mark>
                        <mark type="keyword">tag</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Hardware virtualization of interrupt/exception controller</body>
                    <marks>
                        <mark type="keyword">interrupt</mark>
                        <mark type="keyword">exception</mark>
                        <mark type="keyword">control</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Hardware virtualization of timers</body>
                    <marks>
                        <mark type="keyword">time</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Acceleration of guest switching (Intel VTX: VMCS structure)</body>
                    <marks>
                        <mark type="keyword">switch</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Providing a register with decoded instruction when throwing an exception</body>
                    <marks>
                        <mark type="keyword">register</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are the techniques to introduce paravirtualization?</body>
            <answers>
                <answer>
                    <body>Replace guest drivers with ones provided by the hypervisor.</body>
                    <marks>
                        <mark type="keyword">driver</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Let OS detect hypervisor and automatically use hypercall.</body>
                    <marks>
                        <mark type="keyword">detect</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Let hypervisor patch the guest on the fly</body>
                    <marks>
                        <mark type="keyword">patch</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What are some popular applications of paravirtualization?</body>
            <answers>
                <answer>
                    <body>Guest virtual memory, so that guest can use hypercall to let hypervisor directly modify the
                        page table.
                    </body>
                    <marks>
                        <mark type="keyword">memory</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Block devices (storage or network). Use blocking hypercalls and communicate over a ring
                        buffer.
                    </body>
                    <marks>
                        <mark type="keyword">block</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How can the number of privilege levels of a guest be reduced?</body>
            <answers>
                <answer>
                    <body>By using virtual library os (uni kernels) where resources are provided directly by hypercalls.
                        Drawback: application can corrupt guest OS.
                    </body>
                    <marks>
                        <mark type="keyword">library</mark>
                        <mark type="keyword">uni</mark>
                        <mark type="keyword">corrupt</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What types of guest migration are there?</body>
            <answers>
                <answer>
                    <body>Cold and hot migration. Downtime can be reduced if only small deltas need to be transferred
                        rather than the whole system.
                    </body>
                    <marks>
                        <mark type="keyword">cold</mark>
                        <mark type="keyword">hot</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What types of partitioning exist in multi-processor virtualization and what are some
                advantages/disadvantages?
            </body>
            <answers>
                <answer>
                    <body>Physical partition. Robust, secure, performant. However, utilization is fixed.</body>
                    <marks>
                        <mark type="keyword">physical</mark>
                        <mark type="keyword">robust</mark>
                        <mark type="keyword">secure</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Logical partitioning. Assignment at boot time and sometimes dynamic modification. Aims at
                        better utilization of resources
                    </body>
                    <marks>
                        <mark type="keyword">logical</mark>
                        <mark type="keyword">utiliz</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What mechansim can be used to prevent memory access reordering? How can this be optimized?</body>
            <answers>
                <answer>
                    <body>Prevent by inserting fencing instructions that prevent hardware reordering</body>
                    <marks>
                        <mark type="keyword">fenc</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Optimize by detecting access to private memory and omitting the fence.</body>
                    <marks>
                        <mark type="keyword">private</mark>
                    </marks>
                </answer>
                <answer>
                    <body>Not relevant when accessing the same memory address, since cache coherence guarantees
                        update.
                    </body>
                    <marks>
                        <mark type="keyword">same</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>How can memory be reclaimed from a guest?</body>
            <answers>
                <answer>
                    <body>Using a baloon driver which allocates memory in the guest which is the deallocated in the
                        host.
                    </body>
                    <marks>
                        <mark type="keyword">baloon</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer">
            <body>What does a hybrid vm do?</body>
            <answers>
                <answer>
                    <body>Does same-isa binary translation to filter critical instructions, avoiding the need for
                        hardware support.
                    </body>
                    <marks>
                        <mark type="keyword">translat</mark>
                    </marks>
                </answer>
            </answers>
        </question>
    </body>
</exam>