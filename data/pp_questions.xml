<?xml version="1.0" encoding="UTF-8" ?>

<exam xmlns="https://vpt1.org"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xsi:schemaLocation="https://vpt1.org questions.xsd">
    <head>
        <title>Parallel Programming</title>
        <version>1.0</version>
        <id>161</id>
    </head>
    <body>
        <!-- TODO: Insert questions -->
        <!-- Lecture 2: Threading Concepts Threading APIs POSIX Threads -->
        <question type="extended-answer" id="1">
            <body>What are the four elements of Flynn's taxonomy?</body>
            <answers>
                <answer>
                    <body>SISD (Conventional processor), SIMD (Single instruction multiple data, vectorization, GPU,
                        etc.), MISD (not really available), MIMD (Multiple instruction multiple data,
                        multi-core/processor etc.)
                    </body>
                    <marks>
                        <mark type="keyword">sisd</mark>
                        <mark type="keyword">simd</mark>
                        <mark type="keyword">misd</mark>
                        <mark type="keyword">mimd</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="2">
            <body>What two major types of MIMD architectures exist?</body>
            <answers>
                <answer>
                    <body>Distributed memory and shared memory</body>
                    <marks>
                        <mark type="keyword">distrib</mark>
                        <mark type="keyword">share</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="3">
            <body>What type of distributed memory systems exist and what do they do?</body>
            <answers>
                <answer>
                    <body>MPP, NOW, Cluster (What do they do? TODO)</body>
                    <marks>
                        <mark type="keyword">mpp</mark>
                        <mark type="keyword">now</mark>
                        <mark type="keyword">clust</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="4">
            <body>What are the types and subtypes of shared memory systems?</body>
            <answers>
                <answer>
                    <body>UMA and NUMA (COMA, ccNUMA, nccNUMA)</body>
                    <marks>
                        <mark type="keyword">UMA</mark>
                        <mark type="keyword">NUMA</mark>
                        <mark type="keyword">COMA</mark>
                        <mark type="keyword">cc</mark>
                        <mark type="keyword">ncc</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="5">
            <body>What is another name for the UMA Architecture? What is the defining feature of a UMA system?</body>
            <answers>
                <answer>
                    <body>SMP: Symmetric multiprocessors. There is a centralized shared memory, to which all processors
                        have the same latency.
                    </body>
                    <marks>
                        <mark type="keyword">smp</mark>
                        <mark type="keyword">shared</mark>
                        <mark type="keyword">latenc</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="6">
            <body>What are some programming models that match shared memory?</body>
            <answers>
                <answer>
                    <body>
                        POSIX threads, OpenMP, etc.
                    </body>
                    <marks>
                        <mark type="keyword">posix</mark>
                        <mark type="regex">o(pen)?mp</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="7">
            <body>What is a thread and what are its essential components?</body>
            <answers>
                <answer>
                    <body>An independent stream of execution that has at least its own PC and its own stack.</body>
                    <marks>
                        <mark type="keyword">exec</mark>
                        <mark type="keyword">pc</mark>
                        <mark type="keyword">stack</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="8">
            <body>What is Hyperthreading/SMT?</body>
            <answers>
                <answer>
                    <body>A technology where a processing core can have multiple hardware threads to allow for rapid
                        context switching in the core, reducing the impact of stalls.
                    </body>
                    <marks>
                        <mark type="keyword">thread</mark>
                        <mark type="keyword">switch</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="9">
            <body>What are some advantages of using threads versus multiple processes.</body>
            <answers>
                <answer>
                    <body>
                        No data protection boundaries, asynchronous behavior within a process, OS still does scheduling
                        (preemption and progress)
                    </body>
                    <marks>
                        <mark type="keyword">protect</mark>
                        <mark type="keyword">async</mark>
                        <mark type="keyword">schedul</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="10">
            <body>What is an advantage of using threads (e.g. pthreads) in parallel programming?</body>
            <answers>
                <answer>
                    <body>Its low-level, allowing the programmer to micro-manage resources.</body>
                    <marks>
                        <mark type="keyword">low</mark>
                        <mark type="keyword">resource</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="11">
            <body>What model does pthreads conform to?</body>
            <answers>
                <answer>
                    <body>The fork/join model</body>
                    <marks>
                        <mark type="keyword">fork</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="12">
            <body>Write code to create/destroy a pthread.</body>
            <answers>
                <answer>
                    <body>
                        Using a kernel:
                        <pre>void* kernel(void* arg);</pre>
                        Start a thread:
                        <pre>
                            pthread_t thread;
                            pthread_attr_t attr;
                            if(!pthread_create(&amp;thread, attr, kernel, arg)) {
                            abort(0);
                            }
                        </pre>
                        Join a thread:
                        <pre>
                            if(!pthread_join(&amp;thread, &amp;retval)) {
                            abort(0);
                            }
                        </pre>
                    </body>
                    <marks>
                        <mark type="keyword">create</mark>
                        <mark type="keyword">join</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="13">
            <body>What is a potential issue when using pthreads concerning memory?</body>
            <answers>
                <answer>
                    <body>The stacks of multiple threads need to be stored in the same address space. Usually, this is
                        done with a pre-defined space between each stack, limiting the amount of available stack space.
                    </body>
                    <marks>
                        <mark type="keyword">stack</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="14">
            <body>What are the two main concepts for synchronization between threads in POSIX?</body>
            <answers>
                <answer>
                    <body>Mutual exclusion, condition variables</body>
                    <marks>
                        <mark type="keyword">excl</mark>
                        <mark type="keyword">condit</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="15">
            <body>Which problem is solved by the mutual exclusion concept?</body>
            <answers>
                <answer>
                    <body>Concurrent access to shared resources (IO, Memory, etc.)</body>
                    <marks>
                        <mark type="keyword">resourc</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="16">
            <body>Write code for one lifecycle of a POSIX Mutex.</body>
            <answers>
                <answer>
                    <body>
                        Initialization (to use default attributes, use NULL):
                        <pre>
                            //Dynamic case, destruction necessary
                            pthread_mutex_t lock;
                            pthread_mutex_init(&amp;lock, attr);
                            //Static case
                            pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
                        </pre>
                        Lock:
                        <pre>
                            pthread_mutex_lock(&amp;lock);
                            pthread_mutex_trylock(&amp;lock);
                        </pre>
                        Unlock:
                        <pre>
                            pthread_mutex_unlock(&amp;lock);
                        </pre>
                        Destroy:
                        <pre>
                            pthread_mutex_destroy(&amp;lock);
                        </pre>
                    </body>
                    <marks></marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="17">
            <body>What types of recursive behaviors are available for pthread mutexes?</body>
            <answers>
                <answer>
                    <body>PTHREAD_MUTEX_NORMAL (deadlock), PTHREAD_MUTEX_ERRORCHECK (error code),
                        PTHREAD_MUTEX_RECURSIVE (lock count). Default: undefined behavior
                    </body>
                    <marks>
                        <mark type="keyword">normal</mark>
                        <mark type="keyword">error</mark>
                        <mark type="keyword">recur</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="18">
            <body>What criteria are there for the implementation of a pthread mutex?</body>
            <answers>
                <answer>
                    <body>Guarantee of mutual exclusion, progress (every waiting thread eventually gets the mutex),
                        fairness.
                    </body>
                    <marks>
                        <mark type="keyword">excl</mark>
                        <mark type="keyword">prog</mark>
                        <mark type="keyword">fair</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="19">
            <body>What are the two typical implementations for a pthread mutex and what do they do?</body>
            <answers>
                <answer>
                    <body>
                        Spin-lock: Try to obtain lock in a loop as fast as possible, enable low latency but consuming
                        resources.
                        <p/>
                        Yielding lock: Yields the hardware thread when lock unavailable, freeing resources but
                        increasing latency.
                    </body>
                    <marks>
                        <mark type="keyword">spin</mark>
                        <mark type="keyword">yield</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="20">
            <body>What implementations of a mutex exist with/without hardware support?</body>
            <answers>
                <answer>
                    <body>HW Support: Locking using atomic operations, such as test and set or compare and swap. No HW
                        Support: Using e.g. Petersen's algorithm.
                    </body>
                    <marks>
                        <mark type="keyword">atomic</mark>
                        <mark type="keyword">petersen</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="21">
            <body>What is the tradeoff with lock granularity?</body>
            <answers>
                <answer>
                    <body>Too fine and a significant portion of compute time will be spent on obtaining and releasing
                        locks. Too coarse and threads will need to wait for accessing resources that could be accessed
                        concurrently.
                    </body>
                    <marks>
                        <mark type="keyword">time</mark>
                        <mark type="keyword">resourc</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="22">
            <body>When does a deadlock occur?</body>
            <answers>
                <answer>
                    <body>When there is a cyclic dependency when obtaining locks.</body>
                    <marks>
                        <mark type="keyword">cycl</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="23">
            <body>What approaches exist to resolve the deadlock problem and what is a drawback of each?</body>
            <answers>
                <answer>
                    <body>One lock (very coarse). Arbiter (complex central instance, scalability). Lock order
                        (fairness). Custom/hybrid schemes.
                    </body>
                    <marks>
                        <mark type="keyword">one</mark>
                        <mark type="keyword">arbit</mark>
                        <mark type="keyword">order</mark>
                        <mark type="keyword">hybrid</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="24">
            <body>What is the concept behind condition variables for synchronization?</body>
            <answers>
                <answer>
                    <body>One thread blocks while the other thread sends a signal once the condition is met.</body>
                    <marks>
                        <mark type="keyword">block</mark>
                        <mark type="keyword">signal</mark>
                    </marks>
                </answer>
            </answers>
        </question>
        <question type="extended-answer" id="25">
            <body>How are pthread condition variables used?</body>
            <answers>
                <answer>
                    <body>
                        Initialization:
                        <pre>
                            pthread_cond_t cond = pthread_cond_init
                        </pre>
                    </body>
                    <marks></marks>
                </answer>
            </answers>
        </question>
        <!-- TODO: Continue Chapter 2 slide 45 -->


    </body>
</exam>